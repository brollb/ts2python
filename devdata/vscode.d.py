# Generated by ts2python on 2022-02-26 22:54:13.588041


import sys
from enum import Enum, IntEnum
if sys.version_info >= (3, 9, 0):
    from typing import Union, Optional, Any, Generic, TypeVar, Callable
    List = list
    Tuple = tuple
    Dict = dict
    from collections.abc import Coroutine
else:
    from typing import Union, List, Tuple, Optional, Dict, Any, Generic, TypeVar, Callable, Coroutine


try:
    from ts2python.json_validation import TypedDict, GenericTypedDict, NotRequired, Literal
    # Overwrite typing.TypedDict for Runtime-Validation
except ImportError:
    # print("Module ts2python.json_validation not found. Only " 
    #       "coarse-grained type-validation of TypedDicts possible")
    try:
        from typing import TypedDict, Literal
    except ImportError:
        try:
            from ts2python.typing_extensions import TypedDict, Literal
        except ImportError:
            print(f'Please install the "typing_extensions" module via the shell '
                  f'command "# pip install typing_extensions" before running '
                  f'{__file__} with Python-versions <= 3.7!')
    try:
        from typing_extensions import NotRequired
    except ImportError:
        NotRequired = Optional
    if sys.version_info >= (3, 7, 0):  GenericMeta = type
    else:
        from typing import GenericMeta
    class _GenericTypedDictMeta(GenericMeta):
        def __new__(cls, name, bases, ns, total=True):
            return type.__new__(_GenericTypedDictMeta, name, (dict,), ns)
        __call__ = dict
    GenericTypedDict = _GenericTypedDictMeta('TypedDict', (dict,), {})
    GenericTypedDict.__module__ = __name__


source_hash__ = "34ec60f947d23b709d2761707c515169 c7d3bfd173be3836a98f54bd1488b027"


##### BEGIN OF LSP SPECS


version: str


class Command(TypedDict, total=False):
    title: str
    command: str
    tooltip: Optional[str]
    arguments: Optional[List[Any]]


class TextLine(TypedDict, total=True):
    lineNumber: float
    text: str
    range: 'Range'
    rangeIncludingLineBreak: 'Range'
    firstNonWhitespaceCharacterIndex: float
    isEmptyOrWhitespace: bool


class TextDocument:
    uri: 'Uri'
    fileName: str
    isUntitled: bool
    languageId: str
    version: float
    isDirty: bool
    isClosed: bool
    
    def save(self) -> Coroutine[bool]:
        pass
    eol: 'EndOfLine'
    lineCount: float
    
    def lineAt(self, line: float) -> TextLine:
        pass
    
    def lineAt(self, position: 'Position') -> TextLine:
        pass
    
    def offsetAt(self, position: 'Position') -> float:
        pass
    
    def positionAt(self, offset: float) -> 'Position':
        pass
    
    def getText(self, range: Optional['Range'] = None) -> str:
        pass
    
    def getWordRangeAtPosition(self, position: 'Position', regex: Optional[str] = None) -> Union['Range', None]:
        pass
    
    def validateRange(self, range: 'Range') -> 'Range':
        pass
    
    def validatePosition(self, position: 'Position') -> 'Position':
        pass


class Position:
    class Position_0(TypedDict, total=False):
        lineDelta: Optional[float]
        characterDelta: Optional[float]
    class Position_0(TypedDict, total=False):
        line: Optional[float]
        character: Optional[float]
    line: float
    character: float
    
    def __init__(self, line: float, character: float) -> Any:
        pass
    
    def isBefore(self, other: 'Position') -> bool:
        pass
    
    def isBeforeOrEqual(self, other: 'Position') -> bool:
        pass
    
    def isAfter(self, other: 'Position') -> bool:
        pass
    
    def isAfterOrEqual(self, other: 'Position') -> bool:
        pass
    
    def isEqual(self, other: 'Position') -> bool:
        pass
    
    def compareTo(self, other: 'Position') -> float:
        pass
    
    def translate(self, lineDelta: Optional[float] = None, characterDelta: Optional[float] = None) -> 'Position':
        pass
    
    def translate(self, change: Position_0) -> 'Position':
        pass
    
    def with_(self, line: Optional[float] = None, character: Optional[float] = None) -> 'Position':
        pass
    
    def with_(self, change: Position_0) -> 'Position':
        pass


class Range:
    class Range_0(TypedDict, total=False):
        start: Optional[Position]
        end: Optional[Position]
    start: Position
    end: Position
    
    def __init__(self, start: Position, end: Position) -> Any:
        pass
    
    def __init__(self, startLine: float, startCharacter: float, endLine: float, endCharacter: float) -> Any:
        pass
    isEmpty: bool
    isSingleLine: bool
    
    def contains(self, positionOrRange: Union[Position, 'Range']) -> bool:
        pass
    
    def isEqual(self, other: 'Range') -> bool:
        pass
    
    def intersection(self, range: 'Range') -> Union['Range', None]:
        pass
    
    def union(self, other: 'Range') -> 'Range':
        pass
    
    def with_(self, start: Optional[Position] = None, end: Optional[Position] = None) -> 'Range':
        pass
    
    def with_(self, change: Range_0) -> 'Range':
        pass


class Selection(Range):
    anchor: Position
    active: Position
    
    def __init__(self, anchor: Position, active: Position) -> Any:
        pass
    
    def __init__(self, anchorLine: float, anchorCharacter: float, activeLine: float, activeCharacter: float) -> Any:
        pass
    isReversed: bool


class TextEditorSelectionChangeKind(IntEnum):
    Keyboard = 1
    Mouse = 2
    Command = 3


class TextEditorSelectionChangeEvent(TypedDict, total=True):
    textEditor: 'TextEditor'
    selections: List[Selection]
    kind: Union[TextEditorSelectionChangeKind, None]


class TextEditorVisibleRangesChangeEvent(TypedDict, total=True):
    textEditor: 'TextEditor'
    visibleRanges: List[Range]


class TextEditorOptionsChangeEvent(TypedDict, total=True):
    textEditor: 'TextEditor'
    options: 'TextEditorOptions'


class TextEditorViewColumnChangeEvent(TypedDict, total=True):
    textEditor: 'TextEditor'
    viewColumn: 'ViewColumn'


class TextEditorCursorStyle(IntEnum):
    Line = 1
    Block = 2
    Underline = 3
    LineThin = 4
    BlockOutline = 5
    UnderlineThin = 6


class TextEditorLineNumbersStyle(IntEnum):
    Off = 0
    On = 1
    Relative = 2


class TextEditorOptions(TypedDict, total=False):
    tabSize: Union[float, str, None]
    insertSpaces: Union[bool, str, None]
    cursorStyle: Optional[TextEditorCursorStyle]
    lineNumbers: Optional[TextEditorLineNumbersStyle]


class TextEditorDecorationType:
    key: str
    
    def dispose(self) -> None:
        pass


class TextEditorRevealType(IntEnum):
    Default = 0
    InCenter = 1
    InCenterIfOutsideViewport = 2
    AtTop = 3


class OverviewRulerLane(IntEnum):
    Left = 1
    Center = 2
    Right = 4
    Full = 7


class DecorationRangeBehavior(IntEnum):
    OpenOpen = 0
    ClosedClosed = 1
    OpenClosed = 2
    ClosedOpen = 3


class TextDocumentShowOptions(TypedDict, total=False):
    viewColumn: Optional['ViewColumn']
    preserveFocus: Optional[bool]
    preview: Optional[bool]
    selection: Optional[Range]


class ThemeColor:
    
    def __init__(self, id: str) -> Any:
        pass


class ThemeIcon:
    File: 'ThemeIcon'
    Folder: 'ThemeIcon'
    id: str
    color: Union[ThemeColor, None]
    
    def __init__(self, id: str, color: Optional[ThemeColor] = None) -> Any:
        pass


class ThemableDecorationRenderOptions(TypedDict, total=False):
    backgroundColor: Union[str, ThemeColor, None]
    outline: Optional[str]
    outlineColor: Union[str, ThemeColor, None]
    outlineStyle: Optional[str]
    outlineWidth: Optional[str]
    border: Optional[str]
    borderColor: Union[str, ThemeColor, None]
    borderRadius: Optional[str]
    borderSpacing: Optional[str]
    borderStyle: Optional[str]
    borderWidth: Optional[str]
    fontStyle: Optional[str]
    fontWeight: Optional[str]
    textDecoration: Optional[str]
    cursor: Optional[str]
    color: Union[str, ThemeColor, None]
    opacity: Optional[str]
    terSpacing: Optional[str]
    gutterIconPath: Union[str, 'Uri', None]
    gutterIconSize: Optional[str]
    overviewRulerColor: Union[str, ThemeColor, None]
    before: Optional['ThemableDecorationAttachmentRenderOptions']
    after: Optional['ThemableDecorationAttachmentRenderOptions']


class ThemableDecorationAttachmentRenderOptions(TypedDict, total=False):
    contentText: Optional[str]
    contentIconPath: Union[str, 'Uri', None]
    border: Optional[str]
    borderColor: Union[str, ThemeColor, None]
    fontStyle: Optional[str]
    fontWeight: Optional[str]
    textDecoration: Optional[str]
    color: Union[str, ThemeColor, None]
    backgroundColor: Union[str, ThemeColor, None]
    margin: Optional[str]
    width: Optional[str]
    height: Optional[str]


class DecorationRenderOptions(ThemableDecorationRenderOptions, TypedDict, total=False):
    isWholeLine: Optional[bool]
    rangeBehavior: Optional[DecorationRangeBehavior]
    overviewRulerLane: Optional[OverviewRulerLane]
    light: Optional[ThemableDecorationRenderOptions]
    dark: Optional[ThemableDecorationRenderOptions]


class DecorationOptions(TypedDict, total=False):
    range: Range
    hoverMessage: Union['MarkdownString', 'MarkedString', List[Union['MarkdownString', 'MarkedString']], None]
    renderOptions: Optional['DecorationInstanceRenderOptions']


class ThemableDecorationInstanceRenderOptions(TypedDict, total=False):
    before: Optional[ThemableDecorationAttachmentRenderOptions]
    after: Optional[ThemableDecorationAttachmentRenderOptions]


class DecorationInstanceRenderOptions(ThemableDecorationInstanceRenderOptions, TypedDict, total=False):
    light: Optional[ThemableDecorationInstanceRenderOptions]
    dark: Optional[ThemableDecorationInstanceRenderOptions]


class TextEditor:
    class TextEditor_0(TypedDict, total=True):
        undoStopBefore: bool
        undoStopAfter: bool
    class TextEditor_0(TypedDict, total=True):
        undoStopBefore: bool
        undoStopAfter: bool
    document: TextDocument
    selection: Selection
    selections: List[Selection]
    visibleRanges: List[Range]
    options: TextEditorOptions
    viewColumn: Union['ViewColumn', None]
    
    def edit(self, callback: Callable[['TextEditorEdit'], None], options: Optional[TextEditor_0] = None) -> Coroutine[bool]:
        pass
    
    def insertSnippet(self, snippet: 'SnippetString', location: Optional[Union[Position, Range, List[Position], List[Range]]] = None, options: Optional[TextEditor_0] = None) -> Coroutine[bool]:
        pass
    
    def setDecorations(self, decorationType: TextEditorDecorationType, rangesOrOptions: Union[List[Range], List[DecorationOptions]]) -> None:
        pass
    
    def revealRange(self, range: Range, revealType: Optional[TextEditorRevealType] = None) -> None:
        pass
    
    def show(self, column: Optional['ViewColumn'] = None) -> None:
        pass
    
    def hide(self) -> None:
        pass


class EndOfLine(IntEnum):
    LF = 1
    CRLF = 2


class TextEditorEdit:
    
    def replace(self, location: Union[Position, Range, Selection], value: str) -> None:
        pass
    
    def insert(self, location: Position, value: str) -> None:
        pass
    
    def delete(self, location: Union[Range, Selection]) -> None:
        pass
    
    def setEndOfLine(self, endOfLine: EndOfLine) -> None:
        pass


class Uri:
    class Uri_0(TypedDict, total=False):
        scheme: str
        authority: Optional[str]
        path: Optional[str]
        query: Optional[str]
        fragment: Optional[str]
    class Uri_0(TypedDict, total=False):
        scheme: Optional[str]
        authority: Optional[str]
        path: Optional[str]
        query: Optional[str]
        fragment: Optional[str]
    
    def parse(self, value: str, strict: Optional[bool] = None) -> 'Uri':
        pass
    
    def file(self, path: str) -> 'Uri':
        pass
    
    def joinPath(self, base: 'Uri', *pathSegments: str) -> 'Uri':
        pass
    
    def from_(self, components: Uri_0) -> 'Uri':
        pass
    private: Any
    
    def __init__(self, scheme: str, authority: str, path: str, query: str, fragment: str) -> Any:
        pass
    scheme: str
    authority: str
    path: str
    query: str
    fragment: str
    fsPath: str
    
    def with_(self, change: Uri_0) -> 'Uri':
        pass
    
    def toString(self, skipEncoding: Optional[bool] = None) -> str:
        pass
    
    def toJSON(self) -> Any:
        pass


class CancellationToken(TypedDict, total=True):
    isCancellationRequested: bool
    onCancellationRequested: 'Event[Any]'


class CancellationTokenSource:
    token: CancellationToken
    
    def cancel(self) -> None:
        pass
    
    def dispose(self) -> None:
        pass


class CancellationError(Exception):
    
    def __init__(self) -> Any:
        pass


class Disposable:
    class Disposable_0(TypedDict, total=True):
        dispose: Callable[[], Any]
    
    def from_(self, *disposableLikes: Disposable_0) -> 'Disposable':
        pass
    
    def __init__(self, callOnDispose: Callable[[], Any]) -> Any:
        pass
    
    def dispose(self) -> Any:
        pass


T = TypeVar('T')


class Event(Generic[T]):
    
    def __call__(self, listener: Callable[[T], Any], thisArgs: Optional[Any] = None, disposables: Optional[List[Disposable]] = None) -> Disposable:
        pass


T = TypeVar('T')


class EventEmitter(Generic[T]):
    event: Event[T]
    
    def fire(self, data: T) -> None:
        pass
    
    def dispose(self) -> None:
        pass


class FileSystemWatcher(Disposable):
    ignoreCreateEvents: bool
    ignoreChangeEvents: bool
    ignoreDeleteEvents: bool
    onDidCreate: Event[Uri]
    onDidChange: Event[Uri]
    onDidDelete: Event[Uri]


class TextDocumentContentProvider:
    onDidChange: Optional[Event[Uri]]
    
    def provideTextDocumentContent(self, uri: Uri, token: CancellationToken) -> 'ProviderResult[str]':
        pass


class QuickPickItemKind(IntEnum):
    Separator = -1
    Default = 0


class QuickPickItem(TypedDict, total=False):
    label: str
    kind: Optional[QuickPickItemKind]
    description: Optional[str]
    detail: Optional[str]
    picked: Optional[bool]
    alwaysShow: Optional[bool]
    buttons: Optional[List['QuickInputButton']]


class QuickPickOptions:
    title: Optional[str]
    matchOnDescription: Optional[bool]
    matchOnDetail: Optional[bool]
    placeHolder: Optional[str]
    ignoreFocusOut: Optional[bool]
    canPickMany: Optional[bool]
    
    def onDidSelectItem(self, item: Union[QuickPickItem, str]) -> Any:
        pass


class WorkspaceFolderPickOptions(TypedDict, total=False):
    placeHolder: Optional[str]
    ignoreFocusOut: Optional[bool]


class OpenDialogOptions(TypedDict, total=False):
    defaultUri: Optional[Uri]
    openLabel: Optional[str]
    canSelectFiles: Optional[bool]
    canSelectFolders: Optional[bool]
    canSelectMany: Optional[bool]
    filters: Optional[Dict[str, List[str]]]
    title: Optional[str]


class SaveDialogOptions(TypedDict, total=False):
    defaultUri: Optional[Uri]
    saveLabel: Optional[str]
    filters: Optional[Dict[str, List[str]]]
    title: Optional[str]


class MessageItem(TypedDict, total=False):
    title: str
    isCloseAffordance: Optional[bool]


class MessageOptions(TypedDict, total=False):
    modal: Optional[bool]
    detail: Optional[str]


class InputBoxOptions:
    title: Optional[str]
    value: Optional[str]
    valueSelection: Optional[Tuple[float, float]]
    prompt: Optional[str]
    placeHolder: Optional[str]
    password: Optional[bool]
    ignoreFocusOut: Optional[bool]
    
    def validateInput(self, value: str) -> Union[str, None, Coroutine[Union[str, None]]]:
        pass


class RelativePattern:
    baseUri: Uri
    base: str
    pattern: str
    
    def __init__(self, base: Union['WorkspaceFolder', Uri, str], pattern: str) -> Any:
        pass


GlobPattern = Union[str, RelativePattern]


class DocumentFilter(TypedDict, total=False):
    language: Optional[str]
    scheme: Optional[str]
    pattern: Optional[GlobPattern]


DocumentSelector = Union[DocumentFilter, str, List[Union[DocumentFilter, str]]]


ProviderResult = Union[T, None, Coroutine[Union[T, None]]]


class CodeActionKind:
    Empty: 'CodeActionKind'
    QuickFix: 'CodeActionKind'
    Refactor: 'CodeActionKind'
    RefactorExtract: 'CodeActionKind'
    RefactorInline: 'CodeActionKind'
    RefactorRewrite: 'CodeActionKind'
    Source: 'CodeActionKind'
    SourceOrganizeImports: 'CodeActionKind'
    SourceFixAll: 'CodeActionKind'
    private: Any
    
    def __init__(self, value: str) -> Any:
        pass
    value: str
    
    def append(self, parts: str) -> 'CodeActionKind':
        pass
    
    def intersects(self, other: 'CodeActionKind') -> bool:
        pass
    
    def contains(self, other: 'CodeActionKind') -> bool:
        pass


class CodeActionTriggerKind(IntEnum):
    Invoke = 1
    Automatic = 2


class CodeActionContext(TypedDict, total=True):
    triggerKind: CodeActionTriggerKind
    diagnostics: List['Diagnostic']
    only: Union[CodeActionKind, None]


class CodeAction:
    class Disabled_0(TypedDict, total=True):
        reason: str
    title: str
    edit: Optional['WorkspaceEdit']
    diagnostics: Optional[List['Diagnostic']]
    command: Optional[Command]
    kind: Optional[CodeActionKind]
    isPreferred: Optional[bool]
    disabled: Optional[Disabled_0]
    
    def __init__(self, title: str, kind: Optional[CodeActionKind] = None) -> Any:
        pass


T = TypeVar('T')


class CodeActionProvider(Generic[T]):
    
    def provideCodeActions(self, document: TextDocument, range: Union[Range, Selection], context: CodeActionContext, token: CancellationToken) -> ProviderResult[List[Union[Command, T]]]:
        pass
    
    def resolveCodeAction(self, codeAction: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class CodeActionProviderMetadata(TypedDict, total=False):
    class Documentation_0(TypedDict, total=True):
        kind: CodeActionKind
        command: Command
    providedCodeActionKinds: Optional[List[CodeActionKind]]
    documentation: Optional[List[Documentation_0]]


class CodeLens:
    range: Range
    command: Optional[Command]
    isResolved: bool
    
    def __init__(self, range: Range, command: Optional[Command] = None) -> Any:
        pass


T = TypeVar('T')


class CodeLensProvider(Generic[T]):
    onDidChangeCodeLenses: Optional[Event]
    
    def provideCodeLenses(self, document: TextDocument, token: CancellationToken) -> ProviderResult[List[T]]:
        pass
    
    def resolveCodeLens(self, codeLens: T, token: CancellationToken) -> ProviderResult[T]:
        pass


DefinitionLink = 'LocationLink'


Definition = Union['Location', List['Location']]


class DefinitionProvider:
    
    def provideDefinition(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[Definition, List[DefinitionLink]]]:
        pass


class ImplementationProvider:
    
    def provideImplementation(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[Definition, List[DefinitionLink]]]:
        pass


class TypeDefinitionProvider:
    
    def provideTypeDefinition(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[Definition, List[DefinitionLink]]]:
        pass


Declaration = Union['Location', List['Location'], List['LocationLink']]


class DeclarationProvider:
    
    def provideDeclaration(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Declaration]:
        pass


class MarkdownString:
    value: str
    isTrusted: Optional[bool]
    supportThemeIcons: Optional[bool]
    supportHtml: Optional[bool]
    
    def __init__(self, value: Optional[str] = None, supportThemeIcons: Optional[bool] = None) -> Any:
        pass
    
    def appendText(self, value: str) -> 'MarkdownString':
        pass
    
    def appendMarkdown(self, value: str) -> 'MarkdownString':
        pass
    
    def appendCodeblock(self, value: str, language: Optional[str] = None) -> 'MarkdownString':
        pass


class MarkedString_1(TypedDict, total=True):
    language: str
    value: str
MarkedString = Union[str, MarkedString_1]


class Hover:
    contents: List[Union[MarkdownString, MarkedString]]
    range: Optional[Range]
    
    def __init__(self, contents: Union[MarkdownString, MarkedString, List[Union[MarkdownString, MarkedString]]], range: Optional[Range] = None) -> Any:
        pass


class HoverProvider:
    
    def provideHover(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Hover]:
        pass


class EvaluatableExpression:
    range: Range
    expression: Union[str, None]
    
    def __init__(self, range: Range, expression: Optional[str] = None) -> Any:
        pass


class EvaluatableExpressionProvider:
    
    def provideEvaluatableExpression(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[EvaluatableExpression]:
        pass


class InlineValueText:
    range: Range
    text: str
    
    def __init__(self, range: Range, text: str) -> Any:
        pass


class InlineValueVariableLookup:
    range: Range
    iableName: Union[str, None]
    caseSensitiveLookup: bool
    
    def __init__(self, range: Range, variableName: Optional[str] = None, caseSensitiveLookup: Optional[bool] = None) -> Any:
        pass


class InlineValueEvaluatableExpression:
    range: Range
    expression: Union[str, None]
    
    def __init__(self, range: Range, expression: Optional[str] = None) -> Any:
        pass


InlineValue = Union[InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression]


class InlineValueContext(TypedDict, total=True):
    frameId: float
    stoppedLocation: Range


class InlineValuesProvider:
    onDidChangeInlineValues: Union[Event, None]
    
    def provideInlineValues(self, document: TextDocument, viewPort: Range, context: InlineValueContext, token: CancellationToken) -> ProviderResult[List[InlineValue]]:
        pass


class DocumentHighlightKind(IntEnum):
    Text = 0
    Read = 1
    Write = 2


class DocumentHighlight:
    range: Range
    kind: Optional[DocumentHighlightKind]
    
    def __init__(self, range: Range, kind: Optional[DocumentHighlightKind] = None) -> Any:
        pass


class DocumentHighlightProvider:
    
    def provideDocumentHighlights(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[List[DocumentHighlight]]:
        pass


class SymbolKind(IntEnum):
    File = 0
    Module = 1
    Namespace = 2
    Package = 3
    Class = 4
    Method = 5
    Property = 6
    Field = 7
    Constructor = 8
    Enum = 9
    Interface = 10
    Function = 11
    Variable = 12
    Constant = 13
    String = 14
    Number = 15
    Boolean = 16
    Array = 17
    Object = 18
    Key = 19
    Null = 20
    EnumMember = 21
    Struct = 22
    Event = 23
    Operator = 24
    TypeParameter = 25


class SymbolTag(IntEnum):
    Deprecated = 1


class SymbolInformation:
    name: str
    containerName: str
    kind: SymbolKind
    tags: Optional[List[SymbolTag]]
    location: 'Location'
    
    def __init__(self, name: str, kind: SymbolKind, containerName: str, location: 'Location') -> Any:
        pass
    
    def __init__(self, name: str, kind: SymbolKind, range: Range, uri: Optional[Uri] = None, containerName: Optional[str] = None) -> Any:
        pass


class DocumentSymbol:
    name: str
    detail: str
    kind: SymbolKind
    tags: Optional[List[SymbolTag]]
    range: Range
    selectionRange: Range
    children: List['DocumentSymbol']
    
    def __init__(self, name: str, detail: str, kind: SymbolKind, range: Range, selectionRange: Range) -> Any:
        pass


class DocumentSymbolProvider:
    
    def provideDocumentSymbols(self, document: TextDocument, token: CancellationToken) -> ProviderResult[Union[List[SymbolInformation], List[DocumentSymbol]]]:
        pass


class DocumentSymbolProviderMetadata(TypedDict, total=False):
    label: Optional[str]


T = TypeVar('T')


class WorkspaceSymbolProvider(Generic[T]):
    
    def provideWorkspaceSymbols(self, query: str, token: CancellationToken) -> ProviderResult[List[T]]:
        pass
    
    def resolveWorkspaceSymbol(self, symbol: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class ReferenceContext(TypedDict, total=True):
    includeDeclaration: bool


class ReferenceProvider:
    
    def provideReferences(self, document: TextDocument, position: Position, context: ReferenceContext, token: CancellationToken) -> ProviderResult[List['Location']]:
        pass


class TextEdit:
    
    def replace(self, range: Range, newText: str) -> 'TextEdit':
        pass
    
    def insert(self, position: Position, newText: str) -> 'TextEdit':
        pass
    
    def delete(self, range: Range) -> 'TextEdit':
        pass
    
    def setEndOfLine(self, eol: EndOfLine) -> 'TextEdit':
        pass
    range: Range
    newText: str
    newEol: Optional[EndOfLine]
    
    def __init__(self, range: Range, newText: str) -> Any:
        pass


class WorkspaceEditEntryMetadata(TypedDict, total=False):
    class IconPath_1(TypedDict, total=True):
        light: Uri
        dark: Uri
    needsConfirmation: bool
    label: str
    description: Optional[str]
    iconPath: Union[Uri, IconPath_1, ThemeIcon, None]


class WorkspaceEdit:
    class WorkspaceEdit_0(TypedDict, total=False):
        overwrite: Optional[bool]
        ignoreIfExists: Optional[bool]
    class WorkspaceEdit_0(TypedDict, total=False):
        recursive: Optional[bool]
        ignoreIfNotExists: Optional[bool]
    class WorkspaceEdit_0(TypedDict, total=False):
        overwrite: Optional[bool]
        ignoreIfExists: Optional[bool]
    size: float
    
    def replace(self, uri: Uri, range: Range, newText: str, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass
    
    def insert(self, uri: Uri, position: Position, newText: str, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass
    
    def delete(self, uri: Uri, range: Range, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass
    
    def has(self, uri: Uri) -> bool:
        pass
    
    def set(self, uri: Uri, edits: List[TextEdit]) -> None:
        pass
    
    def get(self, uri: Uri) -> List[TextEdit]:
        pass
    
    def createFile(self, uri: Uri, options: Optional[WorkspaceEdit_0] = None, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass
    
    def deleteFile(self, uri: Uri, options: Optional[WorkspaceEdit_0] = None, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass
    
    def renameFile(self, oldUri: Uri, newUri: Uri, options: Optional[WorkspaceEdit_0] = None, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass
    
    def entries(self) -> List[Tuple[Uri, List[TextEdit]]]:
        pass


class SnippetString:
    value: str
    
    def __init__(self, value: Optional[str] = None) -> Any:
        pass
    
    def appendText(self, string: str) -> 'SnippetString':
        pass
    
    def appendTabstop(self, number: Optional[float] = None) -> 'SnippetString':
        pass
    
    def appendPlaceholder(self, value: Union[str, Callable[['SnippetString'], Any]], number: Optional[float] = None) -> 'SnippetString':
        pass
    
    def appendChoice(self, values: List[str], number: Optional[float] = None) -> 'SnippetString':
        pass
    
    def appendVariable(self, name: str, defaultValue: Union[str, Callable[['SnippetString'], Any]]) -> 'SnippetString':
        pass


class RenameProvider:
    class RenameProvider_1(TypedDict, total=True):
        range: Range
        placeholder: str
    
    def provideRenameEdits(self, document: TextDocument, position: Position, newName: str, token: CancellationToken) -> ProviderResult[WorkspaceEdit]:
        pass
    
    def prepareRename(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[Range, RenameProvider_1]]:
        pass


class SemanticTokensLegend:
    tokenTypes: List[str]
    tokenModifiers: List[str]
    
    def __init__(self, tokenTypes: List[str], tokenModifiers: Optional[List[str]] = None) -> Any:
        pass


class SemanticTokensBuilder:
    
    def __init__(self, legend: Optional[SemanticTokensLegend] = None) -> Any:
        pass
    
    def push(self, line: float, char: float, length: float, tokenType: float, tokenModifiers: Optional[float] = None) -> None:
        pass
    
    def push(self, range: Range, tokenType: str, tokenModifiers: Optional[List[str]] = None) -> None:
        pass
    
    def build(self, resultId: Optional[str] = None) -> 'SemanticTokens':
        pass


class SemanticTokens:
    resultId: Union[str, None]
    data: List[int]
    
    def __init__(self, data: List[int], resultId: Optional[str] = None) -> Any:
        pass


class SemanticTokensEdits:
    resultId: Union[str, None]
    edits: List['SemanticTokensEdit']
    
    def __init__(self, edits: List['SemanticTokensEdit'], resultId: Optional[str] = None) -> Any:
        pass


class SemanticTokensEdit:
    start: float
    deleteCount: float
    data: Union[List[int], None]
    
    def __init__(self, start: float, deleteCount: float, data: Optional[List[int]] = None) -> Any:
        pass


class DocumentSemanticTokensProvider:
    onDidChangeSemanticTokens: Optional[Event]
    
    def provideDocumentSemanticTokens(self, document: TextDocument, token: CancellationToken) -> ProviderResult[SemanticTokens]:
        pass
    
    def provideDocumentSemanticTokensEdits(self, document: TextDocument, previousResultId: str, token: CancellationToken) -> ProviderResult[Union[SemanticTokens, SemanticTokensEdits]]:
        pass


class DocumentRangeSemanticTokensProvider:
    
    def provideDocumentRangeSemanticTokens(self, document: TextDocument, range: Range, token: CancellationToken) -> ProviderResult[SemanticTokens]:
        pass


class FormattingOptions(TypedDict, total=True):
    tabSize: float
    insertSpaces: bool


class DocumentFormattingEditProvider:
    
    def provideDocumentFormattingEdits(self, document: TextDocument, options: FormattingOptions, token: CancellationToken) -> ProviderResult[List[TextEdit]]:
        pass


class DocumentRangeFormattingEditProvider:
    
    def provideDocumentRangeFormattingEdits(self, document: TextDocument, range: Range, options: FormattingOptions, token: CancellationToken) -> ProviderResult[List[TextEdit]]:
        pass


class OnTypeFormattingEditProvider:
    
    def provideOnTypeFormattingEdits(self, document: TextDocument, position: Position, ch: str, options: FormattingOptions, token: CancellationToken) -> ProviderResult[List[TextEdit]]:
        pass


class ParameterInformation:
    label: Union[str, Tuple[float, float]]
    documentation: Union[str, MarkdownString, None]
    
    def __init__(self, label: Union[str, Tuple[float, float]], documentation: Optional[Union[str, MarkdownString]] = None) -> Any:
        pass


class SignatureInformation:
    label: str
    documentation: Union[str, MarkdownString, None]
    parameters: List[ParameterInformation]
    activeParameter: Optional[float]
    
    def __init__(self, label: str, documentation: Optional[Union[str, MarkdownString]] = None) -> Any:
        pass


class SignatureHelp(TypedDict, total=True):
    signatures: List[SignatureInformation]
    activeSignature: float
    activeParameter: float


class SignatureHelpTriggerKind(IntEnum):
    Invoke = 1
    TriggerCharacter = 2
    ContentChange = 3


class SignatureHelpContext(TypedDict, total=True):
    triggerKind: SignatureHelpTriggerKind
    triggerCharacter: Union[str, None]
    isRetrigger: bool
    activeSignatureHelp: Union[SignatureHelp, None]


class SignatureHelpProvider:
    
    def provideSignatureHelp(self, document: TextDocument, position: Position, token: CancellationToken, context: SignatureHelpContext) -> ProviderResult[SignatureHelp]:
        pass


class SignatureHelpProviderMetadata(TypedDict, total=True):
    triggerCharacters: List[str]
    retriggerCharacters: List[str]


class CompletionItemLabel(TypedDict, total=False):
    label: str
    detail: Optional[str]
    description: Optional[str]


class CompletionItemKind(IntEnum):
    Text = 0
    Method = 1
    Function = 2
    Constructor = 3
    Field = 4
    Variable = 5
    Class = 6
    Interface = 7
    Module = 8
    Property = 9
    Unit = 10
    Value = 11
    Enum = 12
    Keyword = 13
    Snippet = 14
    Color = 15
    Reference = 17
    File = 16
    Folder = 18
    EnumMember = 19
    Constant = 20
    Struct = 21
    Event = 22
    Operator = 23
    TypeParameter = 24
    User = 25
    Issue = 26


class CompletionItemTag(IntEnum):
    Deprecated = 1


class CompletionItem:
    class Range_1(TypedDict, total=True):
        inserting: Range
        replacing: Range
    label: Union[str, CompletionItemLabel]
    kind: Optional[CompletionItemKind]
    tags: Optional[List[CompletionItemTag]]
    detail: Optional[str]
    documentation: Union[str, MarkdownString, None]
    sortText: Optional[str]
    filterText: Optional[str]
    preselect: Optional[bool]
    insertText: Union[str, SnippetString, None]
    range: Union[Range, Range_1, None]
    commitCharacters: Optional[List[str]]
    keepWhitespace: Optional[bool]
    textEdit: Optional[TextEdit]
    additionalTextEdits: Optional[List[TextEdit]]
    command: Optional[Command]
    
    def __init__(self, label: Union[str, CompletionItemLabel], kind: Optional[CompletionItemKind] = None) -> Any:
        pass


T = TypeVar('T')


class CompletionList(Generic[T]):
    isIncomplete: Optional[bool]
    items: List[T]
    
    def __init__(self, items: Optional[List[T]] = None, isIncomplete: Optional[bool] = None) -> Any:
        pass


class CompletionTriggerKind(IntEnum):
    Invoke = 0
    TriggerCharacter = 1
    TriggerForIncompleteCompletions = 2


class CompletionContext(TypedDict, total=True):
    triggerKind: CompletionTriggerKind
    triggerCharacter: Union[str, None]


T = TypeVar('T')


class CompletionItemProvider(Generic[T]):
    
    def provideCompletionItems(self, document: TextDocument, position: Position, token: CancellationToken, context: CompletionContext) -> ProviderResult[Union[List[T], CompletionList[T]]]:
        pass
    
    def resolveCompletionItem(self, item: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class DocumentLink:
    range: Range
    target: Optional[Uri]
    tooltip: Optional[str]
    
    def __init__(self, range: Range, target: Optional[Uri] = None) -> Any:
        pass


T = TypeVar('T')


class DocumentLinkProvider(Generic[T]):
    
    def provideDocumentLinks(self, document: TextDocument, token: CancellationToken) -> ProviderResult[List[T]]:
        pass
    
    def resolveDocumentLink(self, link: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class Color:
    red: float
    green: float
    blue: float
    alpha: float
    
    def __init__(self, red: float, green: float, blue: float, alpha: float) -> Any:
        pass


class ColorInformation:
    range: Range
    color: Color
    
    def __init__(self, range: Range, color: Color) -> Any:
        pass


class ColorPresentation:
    label: str
    textEdit: Optional[TextEdit]
    additionalTextEdits: Optional[List[TextEdit]]
    
    def __init__(self, label: str) -> Any:
        pass


class DocumentColorProvider:
    class DocumentColorProvider_0(TypedDict, total=True):
        document: TextDocument
        range: Range
    
    def provideDocumentColors(self, document: TextDocument, token: CancellationToken) -> ProviderResult[List[ColorInformation]]:
        pass
    
    def provideColorPresentations(self, color: Color, context: DocumentColorProvider_0, token: CancellationToken) -> ProviderResult[List[ColorPresentation]]:
        pass


class InlayHintKind(IntEnum):
    Type = 1
    Parameter = 2


class InlayHintLabelPart:
    value: str
    tooltip: Union[str, MarkdownString, None]
    location: Union['Location', None]
    command: Union[Command, None]
    
    def __init__(self, value: str) -> Any:
        pass


class InlayHint:
    position: Position
    label: Union[str, List[InlayHintLabelPart]]
    tooltip: Union[str, MarkdownString, None]
    command: Optional[Command]
    kind: Optional[InlayHintKind]
    paddingLeft: Optional[bool]
    paddingRight: Optional[bool]
    
    def __init__(self, position: Position, label: Union[str, List[InlayHintLabelPart]], kind: Optional[InlayHintKind] = None) -> Any:
        pass


T = TypeVar('T')


class InlayHintsProvider(Generic[T]):
    onDidChangeInlayHints: Optional[Event]
    
    def provideInlayHints(self, document: TextDocument, range: Range, token: CancellationToken) -> ProviderResult[List[T]]:
        pass
    
    def resolveInlayHint(self, hint: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class FoldingRange:
    start: float
    end: float
    kind: Optional['FoldingRangeKind']
    
    def __init__(self, start: float, end: float, kind: Optional['FoldingRangeKind'] = None) -> Any:
        pass


class FoldingRangeKind(IntEnum):
    Comment = 1
    Imports = 2
    Region = 3


class FoldingContext(TypedDict, total=True):
    pass


class FoldingRangeProvider:
    onDidChangeFoldingRanges: Optional[Event]
    
    def provideFoldingRanges(self, document: TextDocument, context: FoldingContext, token: CancellationToken) -> ProviderResult[List[FoldingRange]]:
        pass


class SelectionRange:
    range: Range
    parent: Optional['SelectionRange']
    
    def __init__(self, range: Range, parent: Optional['SelectionRange'] = None) -> Any:
        pass


class SelectionRangeProvider:
    
    def provideSelectionRanges(self, document: TextDocument, positions: List[Position], token: CancellationToken) -> ProviderResult[List[SelectionRange]]:
        pass


class CallHierarchyItem:
    name: str
    kind: SymbolKind
    tags: Optional[List[SymbolTag]]
    detail: Optional[str]
    uri: Uri
    range: Range
    selectionRange: Range
    
    def __init__(self, kind: SymbolKind, name: str, detail: str, uri: Uri, range: Range, selectionRange: Range) -> Any:
        pass


class CallHierarchyIncomingCall:
    from_: CallHierarchyItem
    fromRanges: List[Range]
    
    def __init__(self, item: CallHierarchyItem, fromRanges: List[Range]) -> Any:
        pass


class CallHierarchyOutgoingCall:
    to: CallHierarchyItem
    fromRanges: List[Range]
    
    def __init__(self, item: CallHierarchyItem, fromRanges: List[Range]) -> Any:
        pass


class CallHierarchyProvider:
    
    def prepareCallHierarchy(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[CallHierarchyItem, List[CallHierarchyItem]]]:
        pass
    
    def provideCallHierarchyIncomingCalls(self, item: CallHierarchyItem, token: CancellationToken) -> ProviderResult[List[CallHierarchyIncomingCall]]:
        pass
    
    def provideCallHierarchyOutgoingCalls(self, item: CallHierarchyItem, token: CancellationToken) -> ProviderResult[List[CallHierarchyOutgoingCall]]:
        pass


class TypeHierarchyItem:
    name: str
    kind: SymbolKind
    tags: Optional[List[SymbolTag]]
    detail: Optional[str]
    uri: Uri
    range: Range
    selectionRange: Range
    
    def __init__(self, kind: SymbolKind, name: str, detail: str, uri: Uri, range: Range, selectionRange: Range) -> Any:
        pass


class TypeHierarchyProvider:
    
    def prepareTypeHierarchy(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[TypeHierarchyItem, List[TypeHierarchyItem]]]:
        pass
    
    def provideTypeHierarchySupertypes(self, item: TypeHierarchyItem, token: CancellationToken) -> ProviderResult[List[TypeHierarchyItem]]:
        pass
    
    def provideTypeHierarchySubtypes(self, item: TypeHierarchyItem, token: CancellationToken) -> ProviderResult[List[TypeHierarchyItem]]:
        pass


class LinkedEditingRanges:
    
    def __init__(self, ranges: List[Range], wordPattern: Optional[str] = None) -> Any:
        pass
    ranges: List[Range]
    wordPattern: Union[str, None]


class LinkedEditingRangeProvider:
    
    def provideLinkedEditingRanges(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[LinkedEditingRanges]:
        pass


CharacterPair = Tuple[str, str]


class CommentRule(TypedDict, total=False):
    lineComment: Optional[str]
    blockComment: Optional[CharacterPair]


class IndentationRule(TypedDict, total=False):
    decreaseIndentPattern: str
    increaseIndentPattern: str
    indentNextLinePattern: Optional[str]
    unIndentedLinePattern: Optional[str]


class IndentAction(IntEnum):
    None_ = 0
    Indent = 1
    IndentOutdent = 2
    Outdent = 3


class EnterAction(TypedDict, total=False):
    indentAction: IndentAction
    appendText: Optional[str]
    removeText: Optional[float]


class OnEnterRule(TypedDict, total=False):
    beforeText: str
    afterText: Optional[str]
    previousLineText: Optional[str]
    action: EnterAction


class LanguageConfiguration(TypedDict, total=False):
    class __electricCharacterSupport_0(TypedDict, total=False):
        class DocComment_0(TypedDict, total=False):
            scope: str
            open: str
            lineStart: str
            close: Optional[str]
        brackets: Optional[Any]
        docComment: Optional[DocComment_0]
    class __characterPairSupport_0(TypedDict, total=True):
        class AutoClosingPairs_0(TypedDict, total=False):
            open: str
            close: str
            notIn: Optional[List[str]]
        autoClosingPairs: List[AutoClosingPairs_0]
    comments: Optional[CommentRule]
    brackets: Optional[List[CharacterPair]]
    wordPattern: Optional[str]
    indentationRules: Optional[IndentationRule]
    onEnterRules: Optional[List[OnEnterRule]]
    __electricCharacterSupport: Optional[__electricCharacterSupport_0]
    __characterPairSupport: Optional[__characterPairSupport_0]


class ConfigurationTarget(IntEnum):
    Global = 1
    Workspace = 2
    WorkspaceFolder = 3


class WorkspaceConfiguration:
    class WorkspaceConfiguration_0(TypedDict, total=False):
        key: str
        defaultValue: Optional[T]
        globalValue: Optional[T]
        workspaceValue: Optional[T]
        workspaceFolderValue: Optional[T]
        defaultLanguageValue: Optional[T]
        globalLanguageValue: Optional[T]
        workspaceLanguageValue: Optional[T]
        workspaceFolderLanguageValue: Optional[T]
        languageIds: Optional[List[str]]
    T = TypeVar('T')
    
    def get(self, section: str) -> Union[T, None]:
        pass
    T = TypeVar('T')
    
    def get(self, section: str, defaultValue: T) -> T:
        pass
    
    def has(self, section: str) -> bool:
        pass
    T = TypeVar('T')
    
    def inspect(self, section: str) -> Union[WorkspaceConfiguration_0, None]:
        pass
    
    def update(self, section: str, value: Any, configurationTarget: Optional[Union[ConfigurationTarget, bool, None]] = None, overrideInLanguage: Optional[bool] = None) -> Coroutine:
        pass


class Location:
    uri: Uri
    range: Range
    
    def __init__(self, uri: Uri, rangeOrPosition: Union[Range, Position]) -> Any:
        pass


class LocationLink(TypedDict, total=False):
    originSelectionRange: Optional[Range]
    targetUri: Uri
    targetRange: Range
    targetSelectionRange: Optional[Range]


class DiagnosticChangeEvent(TypedDict, total=True):
    uris: List[Uri]


class DiagnosticSeverity(IntEnum):
    Error = 0
    Warning = 1
    Information = 2
    Hint = 3


class DiagnosticRelatedInformation:
    location: Location
    message: str
    
    def __init__(self, location: Location, message: str) -> Any:
        pass


class DiagnosticTag(IntEnum):
    Unnecessary = 1
    Deprecated = 2


class Diagnostic:
    class Code_2(TypedDict, total=True):
        value: Union[str, float]
        target: Uri
    range: Range
    message: str
    severity: DiagnosticSeverity
    source: Optional[str]
    code: Union[str, float, Code_2, None]
    relatedInformation: Optional[List[DiagnosticRelatedInformation]]
    tags: Optional[List[DiagnosticTag]]
    
    def __init__(self, range: Range, message: str, severity: Optional[DiagnosticSeverity] = None) -> Any:
        pass


class DiagnosticCollection:
    name: str
    
    def set(self, uri: Uri, diagnostics: Union[List[Diagnostic], None]) -> None:
        pass
    
    def set(self, entries: List[Tuple[Uri, Union[List[Diagnostic], None]]]) -> None:
        pass
    
    def delete(self, uri: Uri) -> None:
        pass
    
    def clear(self) -> None:
        pass
    
    def forEach(self, callback: Callable[[Uri, List[Diagnostic], 'DiagnosticCollection'], Any], thisArg: Optional[Any] = None) -> None:
        pass
    
    def get(self, uri: Uri) -> Union[List[Diagnostic], None]:
        pass
    
    def has(self, uri: Uri) -> bool:
        pass
    
    def dispose(self) -> None:
        pass


class LanguageStatusSeverity(IntEnum):
    Information = 0
    Warning = 1
    Error = 2


class LanguageStatusItem:
    id: str
    name: Union[str, None]
    selector: DocumentSelector
    severity: LanguageStatusSeverity
    text: str
    detail: Optional[str]
    busy: bool
    command: Union[Command, None]
    accessibilityInformation: Optional['AccessibilityInformation']
    
    def dispose(self) -> None:
        pass


class ViewColumn(IntEnum):
    Active = -1
    Beside = -2
    One = 1
    Two = 2
    Three = 3
    Four = 4
    Five = 5
    Six = 6
    Seven = 7
    Eight = 8
    Nine = 9


class OutputChannel:
    name: str
    
    def append(self, value: str) -> None:
        pass
    
    def appendLine(self, value: str) -> None:
        pass
    
    def replace(self, value: str) -> None:
        pass
    
    def clear(self) -> None:
        pass
    
    def show(self, preserveFocus: Optional[bool] = None) -> None:
        pass
    
    def show(self, column: Optional[ViewColumn] = None, preserveFocus: Optional[bool] = None) -> None:
        pass
    
    def hide(self) -> None:
        pass
    
    def dispose(self) -> None:
        pass


class AccessibilityInformation(TypedDict, total=False):
    label: str
    role: Optional[str]


class StatusBarAlignment(IntEnum):
    Left = 1
    Right = 2


class StatusBarItem:
    id: str
    alignment: StatusBarAlignment
    priority: Union[float, None]
    name: Union[str, None]
    text: str
    tooltip: Union[str, MarkdownString, None]
    color: Union[str, ThemeColor, None]
    backgroundColor: Union[ThemeColor, None]
    command: Union[str, Command, None]
    accessibilityInformation: Union[AccessibilityInformation, None]
    
    def show(self) -> None:
        pass
    
    def hide(self) -> None:
        pass
    
    def dispose(self) -> None:
        pass


T = TypeVar('T')


class Progress(Generic[T]):
    
    def report(self, value: T) -> None:
        pass


class Terminal:
    name: str
    processId: Coroutine[Union[float, None]]
    creationOptions: 'Readonly[Union[TerminalOptions, ExtensionTerminalOptions]]'
    exitStatus: Union['TerminalExitStatus', None]
    state: 'TerminalState'
    
    def sendText(self, text: str, addNewLine: Optional[bool] = None) -> None:
        pass
    
    def show(self, preserveFocus: Optional[bool] = None) -> None:
        pass
    
    def hide(self) -> None:
        pass
    
    def dispose(self) -> None:
        pass


class TerminalLocation(IntEnum):
    Panel = 1
    Editor = 2


class TerminalEditorLocationOptions(TypedDict, total=False):
    viewColumn: ViewColumn
    preserveFocus: Optional[bool]


class TerminalSplitLocationOptions(TypedDict, total=True):
    parentTerminal: Terminal


class TerminalState(TypedDict, total=True):
    isInteractedWith: bool


class TerminalLinkContext(TypedDict, total=True):
    line: str
    terminal: Terminal


T = TypeVar('T')


class TerminalLinkProvider(Generic[T]):
    
    def provideTerminalLinks(self, context: TerminalLinkContext, token: CancellationToken) -> ProviderResult[List[T]]:
        pass
    
    def handleTerminalLink(self, link: T) -> ProviderResult:
        pass


class TerminalLink:
    startIndex: float
    length: float
    tooltip: Optional[str]
    
    def __init__(self, startIndex: float, length: float, tooltip: Optional[str] = None) -> Any:
        pass


class TerminalProfileProvider:
    
    def provideTerminalProfile(self, token: CancellationToken) -> ProviderResult['TerminalProfile']:
        pass


class TerminalProfile:
    options: Union['TerminalOptions', 'ExtensionTerminalOptions']
    
    def __init__(self, options: Union['TerminalOptions', 'ExtensionTerminalOptions']) -> Any:
        pass


class FileDecoration:
    badge: Optional[str]
    tooltip: Optional[str]
    color: Optional[ThemeColor]
    propagate: Optional[bool]
    
    def __init__(self, badge: Optional[str] = None, tooltip: Optional[str] = None, color: Optional[ThemeColor] = None) -> Any:
        pass


class FileDecorationProvider:
    onDidChangeFileDecorations: Optional[Event[Union[None, Uri, List[Uri]]]]
    
    def provideFileDecoration(self, uri: Uri, token: CancellationToken) -> ProviderResult[FileDecoration]:
        pass


class ExtensionKind(IntEnum):
    UI = 1
    Workspace = 2


T = TypeVar('T')


class Extension(Generic[T]):
    id: str
    extensionUri: Uri
    extensionPath: str
    isActive: bool
    packageJSON: Any
    extensionKind: ExtensionKind
    exports: T
    
    def activate(self) -> Coroutine[T]:
        pass


class ExtensionMode(IntEnum):
    Production = 1
    Development = 2
    Test = 3


class ExtensionContext:
    class Subscriptions(TypedDict, total=True):
        
        def dispose(self) -> Any:
            pass
    subscriptions: List[Subscriptions]
    workspaceState: 'Memento'
    globalState: Any
    secrets: 'SecretStorage'
    extensionUri: Uri
    extensionPath: str
    environmentVariableCollection: 'EnvironmentVariableCollection'
    
    def asAbsolutePath(self, relativePath: str) -> str:
        pass
    storageUri: Union[Uri, None]
    storagePath: Union[str, None]
    globalStorageUri: Uri
    globalStoragePath: str
    logUri: Uri
    logPath: str
    extensionMode: ExtensionMode
    extension: Extension[Any]


class Memento:
    
    def keys(self) -> List[str]:
        pass
    T = TypeVar('T')
    
    def get(self, key: str) -> Union[T, None]:
        pass
    T = TypeVar('T')
    
    def get(self, key: str, defaultValue: T) -> T:
        pass
    
    def update(self, key: str, value: Any) -> Coroutine:
        pass


class SecretStorageChangeEvent(TypedDict, total=True):
    key: str


class SecretStorage:
    
    def get(self, key: str) -> Coroutine[Union[str, None]]:
        pass
    
    def store(self, key: str, value: str) -> Coroutine:
        pass
    
    def delete(self, key: str) -> Coroutine:
        pass
    onDidChange: Event[SecretStorageChangeEvent]


class ColorThemeKind(IntEnum):
    Light = 1
    Dark = 2
    HighContrast = 3


class ColorTheme(TypedDict, total=True):
    kind: ColorThemeKind


class TaskRevealKind(IntEnum):
    Always = 1
    Silent = 2
    Never = 3


class TaskPanelKind(IntEnum):
    Shared = 1
    Dedicated = 2
    New = 3


class TaskPresentationOptions(TypedDict, total=False):
    reveal: Optional[TaskRevealKind]
    echo: Optional[bool]
    focus: Optional[bool]
    panel: Optional[TaskPanelKind]
    showReuseMessage: Optional[bool]
    clear: Optional[bool]


class TaskGroup:
    Clean: 'TaskGroup'
    Build: 'TaskGroup'
    Rebuild: 'TaskGroup'
    Test: 'TaskGroup'
    isDefault: Union[bool, None]
    id: str
    private: Any
    
    def __init__(self, id: str, label: str) -> Any:
        pass


class TaskDefinition(TypedDict, total=True):
    type: str


class ProcessExecutionOptions(TypedDict, total=False):
    cwd: Optional[str]
    env: Optional[Dict[str, str]]


class ProcessExecution:
    
    def __init__(self, process: str, options: Optional[ProcessExecutionOptions] = None) -> Any:
        pass
    
    def __init__(self, process: str, args: List[str], options: Optional[ProcessExecutionOptions] = None) -> Any:
        pass
    process: str
    args: List[str]
    options: Optional[ProcessExecutionOptions]


class ShellQuotingOptions(TypedDict, total=False):
    class Escape_1(TypedDict, total=True):
        escapeChar: str
        charsToEscape: str
    escape: Union[str, Escape_1, None]
    strong: Optional[str]
    weak: Optional[str]


class ShellExecutionOptions(TypedDict, total=False):
    executable: Optional[str]
    shellArgs: Optional[List[str]]
    shellQuoting: Optional[ShellQuotingOptions]
    cwd: Optional[str]
    env: Optional[Dict[str, str]]


class ShellQuoting(IntEnum):
    Escape = 1
    Strong = 2
    Weak = 3


class ShellQuotedString(TypedDict, total=True):
    value: str
    quoting: ShellQuoting


class ShellExecution:
    
    def __init__(self, commandLine: str, options: Optional[ShellExecutionOptions] = None) -> Any:
        pass
    
    def __init__(self, command: Union[str, ShellQuotedString], args: List[Union[str, ShellQuotedString]], options: Optional[ShellExecutionOptions] = None) -> Any:
        pass
    commandLine: Union[str, None]
    command: Union[str, ShellQuotedString]
    args: List[Union[str, ShellQuotedString]]
    options: Optional[ShellExecutionOptions]


class CustomExecution:
    
    def __init__(self, callback: Callable[[TaskDefinition], Coroutine['Pseudoterminal']]) -> Any:
        pass


class TaskScope(IntEnum):
    Global = 1
    Workspace = 2


class RunOptions(TypedDict, total=False):
    reevaluateOnRerun: Optional[bool]


class Task:
    
    def __init__(self, taskDefinition: TaskDefinition, scope: Union['WorkspaceFolder', 'TaskScope.Global', 'TaskScope.Workspace'], name: str, source: str, execution: Optional[Union[ProcessExecution, ShellExecution, CustomExecution]] = None, problemMatchers: Optional[Union[str, List[str]]] = None) -> Any:
        pass
    
    def __init__(self, taskDefinition: TaskDefinition, name: str, source: str, execution: Optional[Union[ProcessExecution, ShellExecution]] = None, problemMatchers: Optional[Union[str, List[str]]] = None) -> Any:
        pass
    definition: TaskDefinition
    scope: Union['TaskScope.Global', 'TaskScope.Workspace', 'WorkspaceFolder', None]
    name: str
    detail: Optional[str]
    execution: Union[ProcessExecution, ShellExecution, CustomExecution, None]
    isBackground: bool
    source: str
    group: Optional[TaskGroup]
    presentationOptions: TaskPresentationOptions
    problemMatchers: List[str]
    runOptions: RunOptions


T = TypeVar('T')


class TaskProvider(Generic[T]):
    
    def provideTasks(self, token: CancellationToken) -> ProviderResult[List[T]]:
        pass
    
    def resolveTask(self, task: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class TaskExecution:
    task: Task
    
    def terminate(self) -> None:
        pass


class TaskStartEvent(TypedDict, total=True):
    execution: TaskExecution


class TaskEndEvent(TypedDict, total=True):
    execution: TaskExecution


class TaskProcessStartEvent(TypedDict, total=True):
    execution: TaskExecution
    processId: float


class TaskProcessEndEvent(TypedDict, total=True):
    execution: TaskExecution
    exitCode: Union[float, None]


class TaskFilter(TypedDict, total=False):
    version: Optional[str]
    type: Optional[str]


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


class FileType(IntEnum):
    Unknown = 0
    File = 1
    Directory = 2
    SymbolicLink = 64


class FilePermission(IntEnum):
    Readonly = 1


class FileStat(TypedDict, total=False):
    type: FileType
    ctime: float
    mtime: float
    size: float
    permissions: Optional[FilePermission]


class FileSystemError(Exception):
    
    def FileNotFound(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass
    
    def FileExists(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass
    
    def FileNotADirectory(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass
    
    def FileIsADirectory(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass
    
    def NoPermissions(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass
    
    def Unavailable(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass
    
    def __init__(self, messageOrUri: Optional[Union[str, Uri]] = None) -> Any:
        pass
    code: str


class FileChangeType(IntEnum):
    Changed = 1
    Created = 2
    Deleted = 3


class FileChangeEvent(TypedDict, total=True):
    type: FileChangeType
    uri: Uri


class FileSystemProvider:
    class FileSystemProvider_0(TypedDict, total=True):
        recursive: bool
        excludes: List[str]
    class FileSystemProvider_0(TypedDict, total=True):
        create: bool
        overwrite: bool
    class FileSystemProvider_0(TypedDict, total=True):
        recursive: bool
    class FileSystemProvider_0(TypedDict, total=True):
        overwrite: bool
    class FileSystemProvider_0(TypedDict, total=True):
        overwrite: bool
    onDidChangeFile: Event[List[FileChangeEvent]]
    
    def watch(self, uri: Uri, options: FileSystemProvider_0) -> Disposable:
        pass
    
    def stat(self, uri: Uri) -> Union[FileStat, Coroutine[FileStat]]:
        pass
    
    def readDirectory(self, uri: Uri) -> Union[List[Tuple[str, FileType]], Coroutine[List[Tuple[str, FileType]]]]:
        pass
    
    def createDirectory(self, uri: Uri) -> Union[None, Coroutine]:
        pass
    
    def readFile(self, uri: Uri) -> Union['Uint8Array', Coroutine['Uint8Array']]:
        pass
    
    def writeFile(self, uri: Uri, content: 'Uint8Array', options: FileSystemProvider_0) -> Union[None, Coroutine]:
        pass
    
    def delete(self, uri: Uri, options: FileSystemProvider_0) -> Union[None, Coroutine]:
        pass
    
    def rename(self, oldUri: Uri, newUri: Uri, options: FileSystemProvider_0) -> Union[None, Coroutine]:
        pass
    
    def copy(self, source: Uri, destination: Uri, options: FileSystemProvider_0) -> Union[None, Coroutine]:
        pass


class FileSystem:
    class FileSystem_0(TypedDict, total=False):
        recursive: Optional[bool]
        useTrash: Optional[bool]
    class FileSystem_0(TypedDict, total=False):
        overwrite: Optional[bool]
    class FileSystem_0(TypedDict, total=False):
        overwrite: Optional[bool]
    
    def stat(self, uri: Uri) -> Coroutine[FileStat]:
        pass
    
    def readDirectory(self, uri: Uri) -> Coroutine[List[Tuple[str, FileType]]]:
        pass
    
    def createDirectory(self, uri: Uri) -> Coroutine:
        pass
    
    def readFile(self, uri: Uri) -> Coroutine['Uint8Array']:
        pass
    
    def writeFile(self, uri: Uri, content: 'Uint8Array') -> Coroutine:
        pass
    
    def delete(self, uri: Uri, options: Optional[FileSystem_0] = None) -> Coroutine:
        pass
    
    def rename(self, source: Uri, target: Uri, options: Optional[FileSystem_0] = None) -> Coroutine:
        pass
    
    def copy(self, source: Uri, target: Uri, options: Optional[FileSystem_0] = None) -> Coroutine:
        pass
    
    def isWritableFileSystem(self, scheme: str) -> Union[bool, None]:
        pass


class WebviewPortMapping(TypedDict, total=True):
    webviewPort: float
    extensionHostPort: float


class WebviewOptions(TypedDict, total=False):
    enableScripts: Optional[bool]
    enableForms: Optional[bool]
    enableCommandUris: Optional[bool]
    localResourceRoots: Optional[List[Uri]]
    portMapping: Optional[List[WebviewPortMapping]]


class Webview:
    options: WebviewOptions
    html: str
    onDidReceiveMessage: Event[Any]
    
    def postMessage(self, message: Any) -> Coroutine[bool]:
        pass
    
    def asWebviewUri(self, localResource: Uri) -> Uri:
        pass
    cspSource: str


class WebviewPanelOptions(TypedDict, total=False):
    enableFindWidget: Optional[bool]
    retainContextWhenHidden: Optional[bool]


class WebviewPanel:
    class IconPath_1(TypedDict, total=True):
        light: Uri
        dark: Uri
    viewType: str
    title: str
    iconPath: Union[Uri, IconPath_1, None]
    webview: Webview
    options: WebviewPanelOptions
    viewColumn: Union[ViewColumn, None]
    active: bool
    visible: bool
    onDidChangeViewState: Event['WebviewPanelOnDidChangeViewStateEvent']
    onDidDispose: Event
    
    def reveal(self, viewColumn: Optional[ViewColumn] = None, preserveFocus: Optional[bool] = None) -> None:
        pass
    
    def dispose(self) -> Any:
        pass


class WebviewPanelOnDidChangeViewStateEvent(TypedDict, total=True):
    webviewPanel: WebviewPanel


T = TypeVar('T')


class WebviewPanelSerializer(Generic[T]):
    
    def deserializeWebviewPanel(self, webviewPanel: WebviewPanel, state: T) -> Coroutine:
        pass


class WebviewView:
    viewType: str
    webview: Webview
    title: Optional[str]
    description: Optional[str]
    onDidDispose: Event
    visible: bool
    onDidChangeVisibility: Event
    
    def show(self, preserveFocus: Optional[bool] = None) -> None:
        pass


T = TypeVar('T')


class WebviewViewResolveContext(Generic[T], GenericTypedDict, total=True):
    state: Union[T, None]


class WebviewViewProvider:
    
    def resolveWebviewView(self, webviewView: WebviewView, context: WebviewViewResolveContext, token: CancellationToken) -> Union[Coroutine, None]:
        pass


class CustomTextEditorProvider:
    
    def resolveCustomTextEditor(self, document: TextDocument, webviewPanel: WebviewPanel, token: CancellationToken) -> Union[Coroutine, None]:
        pass


class CustomDocument:
    uri: Uri
    
    def dispose(self) -> None:
        pass


T = TypeVar('T')


class CustomDocumentEditEvent(Generic[T]):
    document: T
    
    def undo(self) -> Union[Coroutine, None]:
        pass
    
    def redo(self) -> Union[Coroutine, None]:
        pass
    label: Optional[str]


T = TypeVar('T')


class CustomDocumentContentChangeEvent(Generic[T], GenericTypedDict, total=True):
    document: T


class CustomDocumentBackup:
    id: str
    
    def delete(self) -> None:
        pass


class CustomDocumentBackupContext(TypedDict, total=True):
    destination: Uri


class CustomDocumentOpenContext(TypedDict, total=True):
    backupId: Union[str, None]
    untitledDocumentData: Union['Uint8Array', None]


T = TypeVar('T')


class CustomReadonlyEditorProvider(Generic[T]):
    
    def openCustomDocument(self, uri: Uri, openContext: CustomDocumentOpenContext, token: CancellationToken) -> Union[Coroutine[T], T]:
        pass
    
    def resolveCustomEditor(self, document: T, webviewPanel: WebviewPanel, token: CancellationToken) -> Union[Coroutine, None]:
        pass


T = TypeVar('T')


class CustomEditorProvider(CustomReadonlyEditorProvider[T], Generic[T]):
    onDidChangeCustomDocument: Union[Event[CustomDocumentEditEvent[T]], Event[CustomDocumentContentChangeEvent[T]]]
    
    def saveCustomDocument(self, document: T, cancellation: CancellationToken) -> Coroutine:
        pass
    
    def saveCustomDocumentAs(self, document: T, destination: Uri, cancellation: CancellationToken) -> Coroutine:
        pass
    
    def revertCustomDocument(self, document: T, cancellation: CancellationToken) -> Coroutine:
        pass
    
    def backupCustomDocument(self, document: T, context: CustomDocumentBackupContext, cancellation: CancellationToken) -> Coroutine[CustomDocumentBackup]:
        pass


class Clipboard:
    
    def readText(self) -> Coroutine[str]:
        pass
    
    def writeText(self, value: str) -> Coroutine:
        pass


class UIKind(IntEnum):
    Desktop = 1
    Web = 2


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


class WindowState(TypedDict, total=True):
    focused: bool


class UriHandler:
    
    def handleUri(self, uri: Uri) -> ProviderResult:
        pass


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


T = TypeVar('T')


class TreeViewOptions(Generic[T], GenericTypedDict, total=False):
    treeDataProvider: 'TreeDataProvider[T]'
    showCollapseAll: Optional[bool]
    canSelectMany: Optional[bool]


T = TypeVar('T')


class TreeViewExpansionEvent(Generic[T], GenericTypedDict, total=True):
    element: T


T = TypeVar('T')


class TreeViewSelectionChangeEvent(Generic[T], GenericTypedDict, total=True):
    selection: List[T]


class TreeViewVisibilityChangeEvent(TypedDict, total=True):
    visible: bool


T = TypeVar('T')


class TreeView(Disposable, Generic[T]):
    class TreeView_0(TypedDict, total=False):
        select: Optional[bool]
        focus: Optional[bool]
        expand: Union[bool, float, None]
    onDidExpandElement: Event[TreeViewExpansionEvent[T]]
    onDidCollapseElement: Event[TreeViewExpansionEvent[T]]
    selection: List[T]
    onDidChangeSelection: Event[TreeViewSelectionChangeEvent[T]]
    visible: bool
    onDidChangeVisibility: Event[TreeViewVisibilityChangeEvent]
    message: Optional[str]
    title: Optional[str]
    description: Optional[str]
    
    def reveal(self, element: T, options: Optional[TreeView_0] = None) -> Coroutine:
        pass


T = TypeVar('T')


class TreeDataProvider(Generic[T]):
    onDidChangeTreeData: Optional[Event[Union[T, None]]]
    
    def getTreeItem(self, element: T) -> Union['TreeItem', Coroutine['TreeItem']]:
        pass
    
    def getChildren(self, element: Optional[T] = None) -> ProviderResult[List[T]]:
        pass
    
    def getParent(self, element: T) -> ProviderResult[T]:
        pass
    
    def resolveTreeItem(self, item: 'TreeItem', element: T, token: CancellationToken) -> ProviderResult['TreeItem']:
        pass


class TreeItem:
    class IconPath_2(TypedDict, total=True):
        light: Union[str, Uri]
        dark: Union[str, Uri]
    label: Union[str, 'TreeItemLabel', None]
    id: Optional[str]
    iconPath: Union[str, Uri, IconPath_2, ThemeIcon, None]
    description: Union[str, bool, None]
    resourceUri: Optional[Uri]
    tooltip: Union[str, MarkdownString, None]
    command: Optional[Command]
    collapsibleState: Optional['TreeItemCollapsibleState']
    contextValue: Optional[str]
    accessibilityInformation: Optional[AccessibilityInformation]
    
    def __init__(self, label: Union[str, 'TreeItemLabel'], collapsibleState: Optional['TreeItemCollapsibleState'] = None) -> Any:
        pass
    
    def __init__(self, resourceUri: Uri, collapsibleState: Optional['TreeItemCollapsibleState'] = None) -> Any:
        pass


class TreeItemCollapsibleState(IntEnum):
    None_ = 0
    Collapsed = 1
    Expanded = 2


class TreeItemLabel(TypedDict, total=False):
    label: str
    highlights: Optional[List[Tuple[float, float]]]


class TerminalOptions(TypedDict, total=False):
    class IconPath_1(TypedDict, total=True):
        light: Uri
        dark: Uri
    name: Optional[str]
    shellPath: Optional[str]
    shellArgs: Union[List[str], str, None]
    cwd: Union[str, Uri, None]
    env: Optional[Dict[str, Union[str, None]]]
    strictEnv: Optional[bool]
    hideFromUser: Optional[bool]
    message: Optional[str]
    iconPath: Union[Uri, IconPath_1, ThemeIcon, None]
    color: Optional[ThemeColor]
    location: Union[TerminalLocation, TerminalEditorLocationOptions, TerminalSplitLocationOptions, None]
    isTransient: Optional[bool]


class ExtensionTerminalOptions(TypedDict, total=False):
    class IconPath_1(TypedDict, total=True):
        light: Uri
        dark: Uri
    name: str
    pty: 'Pseudoterminal'
    iconPath: Union[Uri, IconPath_1, ThemeIcon, None]
    color: Optional[ThemeColor]
    location: Union[TerminalLocation, TerminalEditorLocationOptions, TerminalSplitLocationOptions, None]
    isTransient: Optional[bool]


class Pseudoterminal:
    onDidWrite: Event[str]
    onDidOverrideDimensions: Optional[Event[Union['TerminalDimensions', None]]]
    onDidClose: Optional[Event[Union[None, float]]]
    onDidChangeName: Optional[Event[str]]
    
    def open(self, initialDimensions: Union['TerminalDimensions', None]) -> None:
        pass
    
    def close(self) -> None:
        pass
    
    def handleInput(self, data: str) -> None:
        pass
    
    def setDimensions(self, dimensions: 'TerminalDimensions') -> None:
        pass


class TerminalDimensions(TypedDict, total=True):
    columns: float
    rows: float


class TerminalExitStatus(TypedDict, total=True):
    code: Union[float, None]


class EnvironmentVariableMutatorType(IntEnum):
    Replace = 1
    Append = 2
    Prepend = 3


class EnvironmentVariableMutator(TypedDict, total=True):
    type: EnvironmentVariableMutatorType
    value: str


class EnvironmentVariableCollection:
    persistent: bool
    
    def replace(self, variable: str, value: str) -> None:
        pass
    
    def append(self, variable: str, value: str) -> None:
        pass
    
    def prepend(self, variable: str, value: str) -> None:
        pass
    
    def get(self, variable: str) -> Union[EnvironmentVariableMutator, None]:
        pass
    
    def forEach(self, callback: Callable[[str, EnvironmentVariableMutator, 'EnvironmentVariableCollection'], Any], thisArg: Optional[Any] = None) -> None:
        pass
    
    def delete(self, variable: str) -> None:
        pass
    
    def clear(self) -> None:
        pass


class ProgressLocation(IntEnum):
    SourceControl = 1
    Window = 10
    Notification = 15


class ProgressOptions(TypedDict, total=False):
    class Location_1(TypedDict, total=True):
        viewId: str
    location: Union[ProgressLocation, Location_1]
    title: Optional[str]
    cancellable: Optional[bool]


class QuickInput:
    title: Union[str, None]
    step: Union[float, None]
    totalSteps: Union[float, None]
    enabled: bool
    busy: bool
    ignoreFocusOut: bool
    
    def show(self) -> None:
        pass
    
    def hide(self) -> None:
        pass
    onDidHide: Event
    
    def dispose(self) -> None:
        pass


T = TypeVar('T')


class QuickPick(QuickInput, Generic[T]):
    value: str
    placeholder: Union[str, None]
    onDidChangeValue: Event[str]
    onDidAccept: Event
    buttons: List['QuickInputButton']
    onDidTriggerButton: Event['QuickInputButton']
    onDidTriggerItemButton: Event['QuickPickItemButtonEvent[T]']
    items: List[T]
    canSelectMany: bool
    matchOnDescription: bool
    matchOnDetail: bool
    keepScrollPosition: Optional[bool]
    activeItems: List[T]
    onDidChangeActive: Event[List[T]]
    selectedItems: List[T]
    onDidChangeSelection: Event[List[T]]


class InputBox(QuickInput):
    value: str
    placeholder: Union[str, None]
    password: bool
    onDidChangeValue: Event[str]
    onDidAccept: Event
    buttons: List['QuickInputButton']
    onDidTriggerButton: Event['QuickInputButton']
    prompt: Union[str, None]
    validationMessage: Union[str, None]


class QuickInputButton(TypedDict, total=False):
    class IconPath_1(TypedDict, total=True):
        light: Uri
        dark: Uri
    iconPath: Union[Uri, IconPath_1, ThemeIcon]
    tooltip: Union[str, None]


class QuickInputButtons:
    Back: QuickInputButton
    private: Any
    
    def __init__(self) -> Any:
        pass


T = TypeVar('T')


class QuickPickItemButtonEvent(Generic[T], GenericTypedDict, total=True):
    button: QuickInputButton
    item: T


class TextDocumentContentChangeEvent(TypedDict, total=True):
    range: Range
    rangeOffset: float
    rangeLength: float
    text: str


class TextDocumentChangeReason(IntEnum):
    Undo = 1
    Redo = 2


class TextDocumentChangeEvent(TypedDict, total=True):
    document: TextDocument
    contentChanges: List[TextDocumentContentChangeEvent]
    reason: Union[TextDocumentChangeReason, None]


class TextDocumentSaveReason(IntEnum):
    Manual = 1
    AfterDelay = 2
    FocusOut = 3


class TextDocumentWillSaveEvent:
    document: TextDocument
    reason: TextDocumentSaveReason
    
    def waitUntil(self, thenable: Coroutine[List[TextEdit]]) -> None:
        pass
    
    def waitUntil(self, thenable: Coroutine[Any]) -> None:
        pass


class FileWillCreateEvent:
    token: CancellationToken
    files: List[Uri]
    
    def waitUntil(self, thenable: Coroutine[WorkspaceEdit]) -> None:
        pass
    
    def waitUntil(self, thenable: Coroutine[Any]) -> None:
        pass


class FileCreateEvent(TypedDict, total=True):
    files: List[Uri]


class FileWillDeleteEvent:
    token: CancellationToken
    files: List[Uri]
    
    def waitUntil(self, thenable: Coroutine[WorkspaceEdit]) -> None:
        pass
    
    def waitUntil(self, thenable: Coroutine[Any]) -> None:
        pass


class FileDeleteEvent(TypedDict, total=True):
    files: List[Uri]


class FileWillRenameEvent:
    class Files_0(TypedDict, total=True):
        oldUri: Uri
        newUri: Uri
    token: CancellationToken
    files: List[Files_0]
    
    def waitUntil(self, thenable: Coroutine[WorkspaceEdit]) -> None:
        pass
    
    def waitUntil(self, thenable: Coroutine[Any]) -> None:
        pass


class FileRenameEvent(TypedDict, total=True):
    class Files_0(TypedDict, total=True):
        oldUri: Uri
        newUri: Uri
    files: List[Files_0]


class WorkspaceFoldersChangeEvent(TypedDict, total=True):
    added: List['WorkspaceFolder']
    removed: List['WorkspaceFolder']


class WorkspaceFolder(TypedDict, total=True):
    uri: Uri
    name: str
    index: float


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


class ConfigurationScope_3(TypedDict, total=False):
    uri: Optional[Uri]
    languageId: str
ConfigurationScope = Union[Uri, TextDocument, WorkspaceFolder, ConfigurationScope_3]


class ConfigurationChangeEvent:
    
    def affectsConfiguration(self, section: str, scope: Optional[ConfigurationScope] = None) -> bool:
        pass


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


class NotebookCellKind(IntEnum):
    Markup = 1
    Code = 2


class NotebookCell(TypedDict, total=True):
    index: float
    notebook: 'NotebookDocument'
    kind: NotebookCellKind
    document: TextDocument
    metadata: Dict[str, Any]
    outputs: List['NotebookCellOutput']
    executionSummary: Union['NotebookCellExecutionSummary', None]


class NotebookEditor(TypedDict, total=True):
    pass


class NotebookRendererMessaging:
    class OnDidReceiveMessage_0(TypedDict, total=True):
        editor: NotebookEditor
        message: Any
    onDidReceiveMessage: Event[OnDidReceiveMessage_0]
    
    def postMessage(self, message: Any, editor: Optional[NotebookEditor] = None) -> Coroutine[bool]:
        pass


class NotebookDocument:
    uri: Uri
    notebookType: str
    version: float
    isDirty: bool
    isUntitled: bool
    isClosed: bool
    metadata: Dict[str, Any]
    cellCount: float
    
    def cellAt(self, index: float) -> NotebookCell:
        pass
    
    def getCells(self, range: Optional['NotebookRange'] = None) -> List[NotebookCell]:
        pass
    
    def save(self) -> Coroutine[bool]:
        pass


class NotebookCellExecutionSummary(TypedDict, total=False):
    class Timing_0(TypedDict, total=True):
        startTime: float
        endTime: float
    executionOrder: Optional[float]
    success: Optional[bool]
    timing: Optional[Timing_0]


class NotebookRange:
    class NotebookRange_0(TypedDict, total=False):
        start: Optional[float]
        end: Optional[float]
    start: float
    end: float
    isEmpty: bool
    
    def __init__(self, start: float, end: float) -> Any:
        pass
    
    def with_(self, change: NotebookRange_0) -> 'NotebookRange':
        pass


class NotebookCellOutputItem:
    
    def text(self, value: str, mime: Optional[str] = None) -> 'NotebookCellOutputItem':
        pass
    
    def json(self, value: Any, mime: Optional[str] = None) -> 'NotebookCellOutputItem':
        pass
    
    def stdout(self, value: str) -> 'NotebookCellOutputItem':
        pass
    
    def stderr(self, value: str) -> 'NotebookCellOutputItem':
        pass
    
    def error(self, value: Exception) -> 'NotebookCellOutputItem':
        pass
    mime: str
    data: 'Uint8Array'
    
    def __init__(self, data: 'Uint8Array', mime: str) -> Any:
        pass


class NotebookCellOutput:
    items: List[NotebookCellOutputItem]
    metadata: Optional[Dict[str, Any]]
    
    def __init__(self, items: List[NotebookCellOutputItem], metadata: Optional[Dict[str, Any]] = None) -> Any:
        pass


class NotebookCellData:
    kind: NotebookCellKind
    value: str
    languageId: str
    outputs: Optional[List[NotebookCellOutput]]
    metadata: Optional[Dict[str, Any]]
    executionSummary: Optional[NotebookCellExecutionSummary]
    
    def __init__(self, kind: NotebookCellKind, value: str, languageId: str) -> Any:
        pass


class NotebookData:
    cells: List[NotebookCellData]
    metadata: Optional[Dict[str, Any]]
    
    def __init__(self, cells: List[NotebookCellData]) -> Any:
        pass


class NotebookSerializer:
    
    def deserializeNotebook(self, content: 'Uint8Array', token: CancellationToken) -> Union[NotebookData, Coroutine[NotebookData]]:
        pass
    
    def serializeNotebook(self, data: NotebookData, token: CancellationToken) -> Union['Uint8Array', Coroutine['Uint8Array']]:
        pass


class NotebookDocumentContentOptions(TypedDict, total=False):
    transientOutputs: Optional[bool]
    transientCellMetadata: Optional[Dict[str, Union[bool, None]]]
    transientDocumentMetadata: Optional[Dict[str, Union[bool, None]]]


class NotebookControllerAffinity(IntEnum):
    Default = 1
    Preferred = 2


class NotebookController:
    class OnDidChangeSelectedNotebooks_0(TypedDict, total=True):
        notebook: NotebookDocument
        selected: bool
    id: str
    notebookType: str
    supportedLanguages: Optional[List[str]]
    label: str
    description: Optional[str]
    detail: Optional[str]
    supportsExecutionOrder: Optional[bool]
    
    def createNotebookCellExecution(self, cell: NotebookCell) -> 'NotebookCellExecution':
        pass
    executeHandler: Callable[[List[NotebookCell], NotebookDocument, 'NotebookController'], Union[None, Coroutine]]
    interruptHandler: Optional[Callable[[NotebookDocument], Union[None, Coroutine]]]
    onDidChangeSelectedNotebooks: Event[OnDidChangeSelectedNotebooks_0]
    
    def updateNotebookAffinity(self, notebook: NotebookDocument, affinity: NotebookControllerAffinity) -> None:
        pass
    
    def dispose(self) -> None:
        pass


class NotebookCellExecution:
    cell: NotebookCell
    token: CancellationToken
    executionOrder: Union[float, None]
    
    def start(self, startTime: Optional[float] = None) -> None:
        pass
    
    def end(self, success: Union[bool, None], endTime: Optional[float] = None) -> None:
        pass
    
    def clearOutput(self, cell: Optional[NotebookCell] = None) -> Coroutine:
        pass
    
    def replaceOutput(self, out: Union[NotebookCellOutput, List[NotebookCellOutput]], cell: Optional[NotebookCell] = None) -> Coroutine:
        pass
    
    def appendOutput(self, out: Union[NotebookCellOutput, List[NotebookCellOutput]], cell: Optional[NotebookCell] = None) -> Coroutine:
        pass
    
    def replaceOutputItems(self, items: Union[NotebookCellOutputItem, List[NotebookCellOutputItem]], output: NotebookCellOutput) -> Coroutine:
        pass
    
    def appendOutputItems(self, items: Union[NotebookCellOutputItem, List[NotebookCellOutputItem]], output: NotebookCellOutput) -> Coroutine:
        pass


class NotebookCellStatusBarAlignment(IntEnum):
    Left = 1
    Right = 2


class NotebookCellStatusBarItem:
    text: str
    alignment: NotebookCellStatusBarAlignment
    command: Union[str, Command, None]
    tooltip: Optional[str]
    priority: Optional[float]
    accessibilityInformation: Optional[AccessibilityInformation]
    
    def __init__(self, text: str, alignment: NotebookCellStatusBarAlignment) -> Any:
        pass


class NotebookCellStatusBarItemProvider:
    onDidChangeCellStatusBarItems: Optional[Event]
    
    def provideCellStatusBarItems(self, cell: NotebookCell, token: CancellationToken) -> ProviderResult[Union[NotebookCellStatusBarItem, List[NotebookCellStatusBarItem]]]:
        pass


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


class SourceControlInputBox(TypedDict, total=True):
    value: str
    placeholder: str
    visible: bool


class QuickDiffProvider:
    
    def provideOriginalResource(self, uri: Uri, token: CancellationToken) -> ProviderResult[Uri]:
        pass


class SourceControlResourceThemableDecorations(TypedDict, total=False):
    iconPath: Union[str, Uri, ThemeIcon, None]


class SourceControlResourceDecorations(SourceControlResourceThemableDecorations, TypedDict, total=False):
    strikeThrough: Optional[bool]
    faded: Optional[bool]
    tooltip: Optional[str]
    light: Optional[SourceControlResourceThemableDecorations]
    dark: Optional[SourceControlResourceThemableDecorations]


class SourceControlResourceState(TypedDict, total=False):
    resourceUri: Uri
    command: Optional[Command]
    decorations: Optional[SourceControlResourceDecorations]
    contextValue: Optional[str]


class SourceControlResourceGroup:
    id: str
    label: str
    hideWhenEmpty: Optional[bool]
    resourceStates: List[SourceControlResourceState]
    
    def dispose(self) -> None:
        pass


class SourceControl:
    id: str
    label: str
    rootUri: Union[Uri, None]
    inputBox: SourceControlInputBox
    count: Optional[float]
    quickDiffProvider: Optional[QuickDiffProvider]
    commitTemplate: Optional[str]
    acceptInputCommand: Optional[Command]
    statusBarCommands: Optional[List[Command]]
    
    def createResourceGroup(self, id: str, label: str) -> SourceControlResourceGroup:
        pass
    
    def dispose(self) -> None:
        pass


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


class DebugProtocolMessage(TypedDict, total=True):
    pass


class DebugProtocolSource(TypedDict, total=True):
    pass


class DebugProtocolBreakpoint(TypedDict, total=True):
    pass


class DebugConfiguration(TypedDict, total=True):
    type: str
    name: str
    request: str


class DebugSession:
    id: str
    type: str
    parentSession: Optional['DebugSession']
    name: str
    workspaceFolder: Union[WorkspaceFolder, None]
    configuration: DebugConfiguration
    
    def customRequest(self, command: str, args: Optional[Any] = None) -> Coroutine[Any]:
        pass
    
    def getDebugProtocolBreakpoint(self, breakpoint: 'Breakpoint') -> Coroutine[Union[DebugProtocolBreakpoint, None]]:
        pass


class DebugSessionCustomEvent(TypedDict, total=True):
    session: DebugSession
    event: str
    body: Any


class DebugConfigurationProvider:
    
    def provideDebugConfigurations(self, folder: Union[WorkspaceFolder, None], token: Optional[CancellationToken] = None) -> ProviderResult[List[DebugConfiguration]]:
        pass
    
    def resolveDebugConfiguration(self, folder: Union[WorkspaceFolder, None], debugConfiguration: DebugConfiguration, token: Optional[CancellationToken] = None) -> ProviderResult[DebugConfiguration]:
        pass
    
    def resolveDebugConfigurationWithSubstitutedVariables(self, folder: Union[WorkspaceFolder, None], debugConfiguration: DebugConfiguration, token: Optional[CancellationToken] = None) -> ProviderResult[DebugConfiguration]:
        pass


class DebugAdapterExecutable:
    
    def __init__(self, command: str, args: Optional[List[str]] = None, options: Optional['DebugAdapterExecutableOptions'] = None) -> Any:
        pass
    command: str
    args: List[str]
    options: Optional['DebugAdapterExecutableOptions']


class DebugAdapterExecutableOptions(TypedDict, total=False):
    env: Optional[Dict[str, str]]
    cwd: Optional[str]


class DebugAdapterServer:
    port: float
    host: Union[str, None]
    
    def __init__(self, port: float, host: Optional[str] = None) -> Any:
        pass


class DebugAdapterNamedPipeServer:
    path: str
    
    def __init__(self, path: str) -> Any:
        pass


class DebugAdapter(Disposable):
    onDidSendMessage: Event[DebugProtocolMessage]
    
    def handleMessage(self, message: DebugProtocolMessage) -> None:
        pass


class DebugAdapterInlineImplementation:
    
    def __init__(self, implementation: DebugAdapter) -> Any:
        pass


DebugAdapterDescriptor = Union[DebugAdapterExecutable, DebugAdapterServer, DebugAdapterNamedPipeServer, DebugAdapterInlineImplementation]


class DebugAdapterDescriptorFactory:
    
    def createDebugAdapterDescriptor(self, session: DebugSession, executable: Union[DebugAdapterExecutable, None]) -> ProviderResult[DebugAdapterDescriptor]:
        pass


class DebugAdapterTracker:
    
    def onWillStartSession(self) -> None:
        pass
    
    def onWillReceiveMessage(self, message: Any) -> None:
        pass
    
    def onDidSendMessage(self, message: Any) -> None:
        pass
    
    def onWillStopSession(self) -> None:
        pass
    
    def onError(self, error: Exception) -> None:
        pass
    
    def onExit(self, code: Union[float, None], signal: Union[str, None]) -> None:
        pass


class DebugAdapterTrackerFactory:
    
    def createDebugAdapterTracker(self, session: DebugSession) -> ProviderResult[DebugAdapterTracker]:
        pass


class DebugConsole:
    
    def append(self, value: str) -> None:
        pass
    
    def appendLine(self, value: str) -> None:
        pass


class BreakpointsChangeEvent(TypedDict, total=True):
    added: List['Breakpoint']
    removed: List['Breakpoint']
    changed: List['Breakpoint']


class Breakpoint:
    id: str
    enabled: bool
    condition: Union[str, None]
    hitCondition: Union[str, None]
    logMessage: Union[str, None]
    protected: Any
    
    def __init__(self, enabled: Optional[bool] = None, condition: Optional[str] = None, hitCondition: Optional[str] = None, logMessage: Optional[str] = None) -> Any:
        pass


class SourceBreakpoint(Breakpoint):
    location: Location
    
    def __init__(self, location: Location, enabled: Optional[bool] = None, condition: Optional[str] = None, hitCondition: Optional[str] = None, logMessage: Optional[str] = None) -> Any:
        pass


class FunctionBreakpoint(Breakpoint):
    functionName: str
    
    def __init__(self, functionName: str, enabled: Optional[bool] = None, condition: Optional[str] = None, hitCondition: Optional[str] = None, logMessage: Optional[str] = None) -> Any:
        pass


class DebugConsoleMode(IntEnum):
    Separate = 0
    MergeWithParent = 1


class DebugSessionOptions(TypedDict, total=False):
    parentSession: Optional[DebugSession]
    lifecycleManagedByParent: Optional[bool]
    consoleMode: Optional[DebugConsoleMode]
    noDebug: Optional[bool]
    compact: Optional[bool]


class DebugConfigurationProviderTriggerKind(IntEnum):
    Initial = 1
    Dynamic = 2


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


class CommentThreadCollapsibleState(IntEnum):
    Collapsed = 0
    Expanded = 1


class CommentMode(IntEnum):
    Editing = 0
    Preview = 1


class CommentThread:
    uri: Uri
    range: Range
    comments: List['Comment']
    collapsibleState: CommentThreadCollapsibleState
    canReply: bool
    contextValue: Optional[str]
    label: Optional[str]
    
    def dispose(self) -> None:
        pass


class CommentAuthorInformation(TypedDict, total=False):
    name: str
    iconPath: Optional[Uri]


class CommentReaction(TypedDict, total=True):
    label: str
    iconPath: Union[str, Uri]
    count: float
    authorHasReacted: bool


class Comment(TypedDict, total=False):
    body: Union[str, MarkdownString]
    mode: CommentMode
    author: CommentAuthorInformation
    contextValue: Optional[str]
    reactions: Optional[List[CommentReaction]]
    label: Optional[str]
    timestamp: Optional['Date']


class CommentReply(TypedDict, total=True):
    thread: CommentThread
    text: str


class CommentingRangeProvider:
    
    def provideCommentingRanges(self, document: TextDocument, token: CancellationToken) -> ProviderResult[List[Range]]:
        pass


class CommentOptions(TypedDict, total=False):
    prompt: Optional[str]
    placeHolder: Optional[str]


class CommentController:
    id: str
    label: str
    options: Optional[CommentOptions]
    commentingRangeProvider: Optional[CommentingRangeProvider]
    
    def createCommentThread(self, uri: Uri, range: Range, comments: List[Comment]) -> CommentThread:
        pass
    reactionHandler: Optional[Callable[[Comment, CommentReaction], Coroutine]]
    
    def dispose(self) -> None:
        pass


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


class AuthenticationSession(TypedDict, total=True):
    id: str
    accessToken: str
    account: 'AuthenticationSessionAccountInformation'
    scopes: List[str]


class AuthenticationSessionAccountInformation(TypedDict, total=True):
    id: str
    label: str


class AuthenticationGetSessionOptions(TypedDict, total=False):
    class ForceNewSession_1(TypedDict, total=True):
        detail: str
    clearSessionPreference: Optional[bool]
    createIfNone: Optional[bool]
    forceNewSession: Union[bool, ForceNewSession_1, None]
    silent: Optional[bool]


class AuthenticationProviderInformation(TypedDict, total=True):
    id: str
    label: str


class AuthenticationSessionsChangeEvent(TypedDict, total=True):
    provider: AuthenticationProviderInformation


class AuthenticationProviderOptions(TypedDict, total=False):
    supportsMultipleAccounts: Optional[bool]


class AuthenticationProviderAuthenticationSessionsChangeEvent(TypedDict, total=True):
    added: Union[List[AuthenticationSession], None]
    removed: Union[List[AuthenticationSession], None]
    changed: Union[List[AuthenticationSession], None]


class AuthenticationProvider:
    onDidChangeSessions: Event[AuthenticationProviderAuthenticationSessionsChangeEvent]
    
    def getSessions(self, scopes: Optional[List[str]] = None) -> Coroutine[List[AuthenticationSession]]:
        pass
    
    def createSession(self, scopes: List[str]) -> Coroutine[AuthenticationSession]:
        pass
    
    def removeSession(self, sessionId: str) -> Coroutine:
        pass


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


# Transpilation of namespaces that contain more than just constant definitions has not yet been implemented.


class TestRunProfileKind(IntEnum):
    Run = 1
    Debug = 2
    Coverage = 3


class TestTag:
    id: str
    
    def __init__(self, id: str) -> Any:
        pass


class TestRunProfile:
    label: str
    kind: TestRunProfileKind
    isDefault: bool
    tag: Union[TestTag, None]
    configureHandler: Union[Callable[[], None], None]
    runHandler: Callable[['TestRunRequest', CancellationToken], Union[Coroutine, None]]
    
    def dispose(self) -> None:
        pass


class TestController:
    id: str
    label: str
    items: 'TestItemCollection'
    
    def createRunProfile(self, label: str, kind: TestRunProfileKind, runHandler: Callable[['TestRunRequest', CancellationToken], Union[Coroutine, None]], isDefault: Optional[bool] = None, tag: Optional[TestTag] = None) -> TestRunProfile:
        pass
    resolveHandler: Optional[Callable[[Union['TestItem', None]], Union[Coroutine, None]]]
    refreshHandler: Union[Callable[[CancellationToken], Union[Coroutine, None]], None]
    
    def createTestRun(self, request: 'TestRunRequest', name: Optional[str] = None, persist: Optional[bool] = None) -> 'TestRun':
        pass
    
    def createTestItem(self, id: str, label: str, uri: Optional[Uri] = None) -> 'TestItem':
        pass
    
    def dispose(self) -> None:
        pass


class TestRunRequest:
    include: Union[List['TestItem'], None]
    exclude: Union[List['TestItem'], None]
    profile: Union[TestRunProfile, None]
    
    def __init__(self, include: Optional[List['TestItem']] = None, exclude: Optional[List['TestItem']] = None, profile: Optional[TestRunProfile] = None) -> Any:
        pass


class TestRun:
    name: Union[str, None]
    token: CancellationToken
    isPersisted: bool
    
    def enqueued(self, test: 'TestItem') -> None:
        pass
    
    def started(self, test: 'TestItem') -> None:
        pass
    
    def skipped(self, test: 'TestItem') -> None:
        pass
    
    def failed(self, test: 'TestItem', message: Union['TestMessage', List['TestMessage']], duration: Optional[float] = None) -> None:
        pass
    
    def errored(self, test: 'TestItem', message: Union['TestMessage', List['TestMessage']], duration: Optional[float] = None) -> None:
        pass
    
    def passed(self, test: 'TestItem', duration: Optional[float] = None) -> None:
        pass
    
    def appendOutput(self, output: str, location: Optional[Location] = None, test: Optional['TestItem'] = None) -> None:
        pass
    
    def end(self) -> None:
        pass


class TestItemCollection:
    size: float
    
    def replace(self, items: List['TestItem']) -> None:
        pass
    
    def forEach(self, callback: Callable[['TestItem', 'TestItemCollection'], Any], thisArg: Optional[Any] = None) -> None:
        pass
    
    def add(self, item: 'TestItem') -> None:
        pass
    
    def delete(self, itemId: str) -> None:
        pass
    
    def get(self, itemId: str) -> Union['TestItem', None]:
        pass


class TestItem(TypedDict, total=False):
    id: str
    uri: Union[Uri, None]
    children: TestItemCollection
    parent: Union['TestItem', None]
    tags: List[TestTag]
    canResolveChildren: bool
    busy: bool
    label: str
    description: Optional[str]
    sortText: Union[str, None]
    range: Union[Range, None]
    error: Union[str, MarkdownString, None]


class TestMessage:
    message: Union[str, MarkdownString]
    expectedOutput: Optional[str]
    actualOutput: Optional[str]
    location: Optional[Location]
    
    def diff(self, message: Union[str, MarkdownString], expected: str, actual: str) -> 'TestMessage':
        pass
    
    def __init__(self, message: Union[str, MarkdownString]) -> Any:
        pass


T = TypeVar('T')


class Thenable(Generic[T]):
    TResult = TypeVar('TResult')
    
    def then(self, onfulfilled: Optional[Callable[[T], Union[TResult, Coroutine[TResult]]]] = None, onrejected: Optional[Callable[[Any], Union[TResult, Coroutine[TResult]]]] = None) -> Coroutine[TResult]:
        pass
    TResult = TypeVar('TResult')
    
    def then(self, onfulfilled: Optional[Callable[[T], Union[TResult, Coroutine[TResult]]]] = None, onrejected: Optional[Callable[[Any], None]] = None) -> Coroutine[TResult]:
        pass


##### END OF LSP SPECS
